<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tools</title>
  <link rel="stylesheet" href="css/layout.css">
  <link rel="stylesheet" href="css/styles.css">
</head>
<body>
    <header>
        <div class="logo">Nicholas Knapp</div>
        <nav>
          <ul>
            <li><a href="tools.html">Tools</a></li>
            <li><a href="cheatsheets.html">Cheat Sheets</a></li>
            <li><a href="index.html#resources">Spreadsheets</a></li>
            <li><a href="index.html#home">Home</a></li>
            <li><a href="index.html#about">About</a></li>
            <li><a href="index.html#services">Services</a></li>
            <li><a href="index.html#opensource">Open-Source Contributions</a></li>   
            <li><a href="index.html#contact">Contact</a></li>
            <li><a href="memes.html">Tech Memes</a></li>
            <li><a href="blog.html">Blog</a></li>
          </ul>
        </nav> 
      </header>
     
  <h1>Styling Playground</h1>

  <h2>Web Components and Shadow DOM: reusable, encapsulated components with custom styles using HTML templates and JavaScript.</h2>
  <custom-card></custom-card>
  <custom-card title="Hello, World!" description="This is a reusable Web Component."></custom-card><p>more text here.</p>
  <p>adding text here.  Formal methods is the term applied to the analysis of software (and computer hardware) whose results are obtained purely through the use of rigorous mathematical methods. The mathematical techniques used include denotational semantics, axiomatic semantics, operational semantics, and abstract interpretation.

    By a straightforward reduction to the halting problem, it is possible to prove that (for any Turing complete language), finding all possible run-time errors in an arbitrary program (or more generally any kind of violation of a specification on the final result of a program) is undecidable: there is no mechanical method that can always answer truthfully whether an arbitrary program may or may not exhibit runtime errors. This result dates from the works of Church, Gödel and Turing in the 1930s (see: Halting problem and Rice's theorem). As with many undecidable questions, one can still attempt to give useful approximate solutions. </p>
  <custom-card title="Item 2" description="Item Description here.  Formal methods is the term applied to the analysis of software (and computer hardware) whose results are obtained purely through the use of rigorous mathematical methods. The mathematical techniques used include denotational semantics, axiomatic semantics, operational semantics, and abstract interpretation.

  By a straightforward reduction to the halting problem, it is possible to prove that (for any Turing complete language), finding all possible run-time errors in an arbitrary program (or more generally any kind of violation of a specification on the final result of a program) is undecidable: there is no mechanical method that can always answer truthfully whether an arbitrary program may or may not exhibit runtime errors. This result dates from the works of Church, Gödel and Turing in the 1930s (see: Halting problem and Rice's theorem). As with many undecidable questions, one can still attempt to give useful approximate solutions. "></custom-card>
  <custom-card title="phased plasma rifle in a 40 watt range" description="background check required"></custom-card>
  <custom-card title="flux capacitor" description="for rent"></custom-card>

  <div style="display: flex; align-items: center; gap: 10px;">
    <custom-card title="Card 1" description="This is the first card."></custom-card>
    <img src="assets/a.jpg" alt="Example Image" width="100">
    <span>Some inline text next to the cards.</span>
    <custom-card title="Card 2" description="This is the second card."></custom-card>
  </div>
  <button id="addCustomCardBtn">Add Custom Card (will not persist)</button>
  <div id="cardContainer" class="card-container"></div>


  <section>
    <h2>Best Practices for Managing CSS</h2>
    <ol>
        <li>Organize your CSS.</li>
        <ul>
            <li>Use a clear file structure.</li>
            <li>Separate concerns by keeping base styles, layout, and components in different files.</li>
            <li>Example:</li>
<code>/css
    ├── base.css  (resets, typography, basic styles)
    ├── layout.css  (grid, flexbox, positioning)
    ├── components.css  (buttons, cards, modals, etc.)
    ├── themes.css  (dark mode, color variations)
    ├── styles.css  (main styles, global rules)
</code>
        </ul>
        <li>Use CSS variables.</li>
        <li>Use a naming convention such as Block, Element, Modifier (BEM).</li>
        <li>Avoid inline styles.</li>
        <li>Minimize repetitive styles.</li>
        <li>Use a CSS reset or normalize.css</li>
        <li>Optimize performance.</li>
        <li>Consider a CSS preprocessor for larger projects.</li>

    </ol>
  </section>


<script src="custom-card.js"></script>

 


  
</body>
</html>